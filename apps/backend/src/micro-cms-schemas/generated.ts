// Auto generated by "microcms_sdk_generator". DO NOT EDIT.
import { z } from "zod";

// cf. https://document.microcms.io/manual/automatic-grant-fields
export const MicroCmsObjectContentFieldsSchema = z.object({
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  publishedAt: z.string().datetime().optional(),
  revisedAt: z.string().datetime().optional(),
});
export type MicroCmsObjectContentFields = z.infer<
  typeof MicroCmsObjectContentFieldsSchema
>;

export const OnlyIdSchema = z.object({
  id: z.string(),
});
export type OnlyId = z.infer<typeof OnlyIdSchema>;

export const MicroCmsListContentFieldsSchema =
  MicroCmsObjectContentFieldsSchema.merge(OnlyIdSchema);
export type MicroCmsListContentFields = z.infer<
  typeof MicroCmsListContentFieldsSchema
>;

export const makeListResponseSchema = <DefTypeSchema extends z.AnyZodObject>(
  defTypeSchema: DefTypeSchema,
) =>
  z.object({
    contents: z.array(MicroCmsListContentFieldsSchema.merge(defTypeSchema)),
    totalCount: z.number(),
    limit: z.number(),
    offset: z.number(),
  });
export type ListResponse = z.infer<ReturnType<typeof makeListResponseSchema>>;

export const ObjectContentMetadataSchema = z.object({
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  publishedAt: z.string().datetime().nullable(),
  revisedAt: z.string().datetime().nullable(),
  closedAt: z.string().datetime().nullable(),
  status: z.tuple([
    z.enum(["DRAFT", "PUBLISH", "PUBLISH_AND_DRAFT", "CLOSED"]),
  ]),
  customStatus: z.tuple([z.unknown()]).nullable(),
  draftKey: z.string().nullable(),
  reservationTime: z
    .object({
      publishTime: z.string().datetime().nullable(),
      stopTime: z.string().datetime().nullable(),
    })
    .nullable(),
});
export type ObjectContentMetadata = z.infer<typeof ObjectContentMetadataSchema>;

export const ListContentMetadataSchema = ObjectContentMetadataSchema.extend({
  id: z.string(),
});
export type ListContentMetadata = z.infer<typeof ListContentMetadataSchema>;

export const AuthorDefSchema = z.object({
  name: z.string(),
  image: z
    .object({
      url: z.string().url(),
      height: z.number(),
      width: z.number(),
    })
    .optional(),
});
export type AuthorDef = z.infer<typeof AuthorDefSchema>;

export const BlogDefSchema = z.object({
  title: z.string(),
  category: OnlyIdSchema.and(z.unknown()),
  author: OnlyIdSchema.and(z.unknown()),
  image: z
    .object({
      url: z.string().url(),
      height: z.number(),
      width: z.number(),
    })
    .optional(),
  body: z.string(),
});
export type BlogDef = z.infer<typeof BlogDefSchema>;

export const CategoryDefSchema = z.object({
  name: z.string(),
});
export type CategoryDef = z.infer<typeof CategoryDefSchema>;

export const AuthorInputSchema = AuthorDefSchema.omit({}).extend({});
export type AuthorInput = z.infer<typeof AuthorInputSchema>;

export const BlogInputSchema = BlogDefSchema.omit({
  category: true,
  author: true,
}).extend({
  category: z.string(),
  author: z.string(),
});
export type BlogInput = z.infer<typeof BlogInputSchema>;

export const CategoryInputSchema = CategoryDefSchema.omit({}).extend({});
export type CategoryInput = z.infer<typeof CategoryInputSchema>;

export const AuthorOutputSchema = makeListResponseSchema(AuthorDefSchema);

export type AuthorOutput = z.infer<typeof AuthorOutputSchema>;

export const AuthorSchema = AuthorOutputSchema.shape.contents.element;

export type Author = z.infer<typeof AuthorSchema>;

export const BlogOutputSchema = makeListResponseSchema(BlogDefSchema);

export type BlogOutput = z.infer<typeof BlogOutputSchema>;

export const BlogSchema = BlogOutputSchema.shape.contents.element;

export type Blog = z.infer<typeof BlogSchema>;

export const CategoryOutputSchema = makeListResponseSchema(CategoryDefSchema);

export type CategoryOutput = z.infer<typeof CategoryOutputSchema>;

export const CategorySchema = CategoryOutputSchema.shape.contents.element;

export type Category = z.infer<typeof CategorySchema>;

export type RequestOptions = RequestInit & {
  customFetcher?: typeof fetch;
};

export type QueryForObjectApi = {
  draftKey?: string;
  fields?: string[];
  depth?: 1 | 2 | 3;
};

export type QueryForListApi = QueryForObjectApi & {
  limit: number;
  offset?: number;
  orders?: string[];
  q?: string;
  ids?: string[];
  filters?: string;
};

export class RequestError extends Error {
  public readonly ok = false;
  public readonly isRequestError = true;
  static {
    this.prototype.name = "RequestError";
  }
  constructor(
    public readonly statusCode: number,
    public readonly responseBody: string,
    public readonly responseHeaders: Headers,
  ) {
    super(`Request failed with status code ${statusCode}: ${responseBody}`);
  }
}

export class ParseResponseError extends Error {
  public readonly ok = false;
  public readonly isParseResponseError = true;
  static {
    this.prototype.name = "ParseResponseError";
  }
  constructor(
    public readonly statusCode: number,
    public readonly data: unknown,
    public readonly parseError: z.ZodError,
    public readonly responseHeaders: Headers,
  ) {
    super(
      `Failed to parse response with status code ${statusCode}: ${parseError.message}: ${JSON.stringify(
        data,
      )}`,
    );
  }
}

export function createClient({
  serviceDomain,
  apiKey,
  requestBaseOptions,
}: {
  serviceDomain: string;
  apiKey: string;
  requestBaseOptions?: RequestOptions;
}) {
  const headers = {
    "Content-Type": "application/json",
    "X-MICROCMS-API-KEY": apiKey,
  };

  function contentUrl(path: string) {
    return new URL(
      path,
      `https://${serviceDomain}.microcms.io/api/v1/`,
    ).toString();
  }
  function managementUrl(path: string) {
    return new URL(
      path,
      `https://${serviceDomain}.microcms-management.io/api/v1/`,
    ).toString();
  }

  async function request<OkResponseSchema extends z.AnyZodObject>(
    url: string,
    okResponseSchema: OkResponseSchema,
    options: RequestOptions,
  ): Promise<
    | {
        ok: true;
        statusCode: number;
        data: z.infer<OkResponseSchema>;
        responseHeaders: Headers;
      }
    | RequestError
    | ParseResponseError
  > {
    const opts = {
      ...requestBaseOptions,
      ...options,
      headers: {
        ...headers,
        ...(requestBaseOptions?.headers ?? {}),
        ...(options?.headers ?? {}),
      },
    };

    const res = await (opts.customFetcher ?? fetch)(url, opts);
    if (!res.ok) {
      return new RequestError(res.status, await res.text(), res.headers);
    }

    let respBody: unknown;
    if (res.status === 202) {
      await res.text();
      respBody = {};
    } else {
      respBody = await res.json();
    }
    const parser = okResponseSchema.safeParse(respBody);
    if (!parser.success) {
      return new ParseResponseError(
        res.status,
        respBody,
        parser.error,
        res.headers,
      );
    }
    return {
      ok: true,
      statusCode: res.status,
      data: parser.data,
      responseHeaders: res.headers,
    };
  }

  function requestGet<OkResponseSchema extends z.AnyZodObject>(
    url: string,
    okResponseSchema: OkResponseSchema,
    query?: QueryForObjectApi | QueryForListApi,
    options?: RequestOptions,
  ): Promise<
    | {
        ok: true;
        statusCode: number;
        data: z.infer<OkResponseSchema>;
        responseHeaders: Headers;
      }
    | RequestError
    | ParseResponseError
  > {
    const searchParams = new URLSearchParams(
      Object.fromEntries(
        Object.entries(query ?? {}).map(([k, v]) => [
          k,
          Array.isArray(v) ? v.join(",") : v.toString(),
        ]),
      ),
    );

    return request(
      url + (searchParams.size > 0 ? `?${searchParams.toString()}` : ""),
      okResponseSchema,
      { ...options, method: "GET" },
    );
  }

  function requestWrite<OkResponseSchema extends z.AnyZodObject>(
    method: "POST" | "PUT" | "PATCH" | "DELETE",
    url: string,
    okResponseSchema: OkResponseSchema,
    content?: unknown,
    options?: RequestOptions,
  ): Promise<
    | {
        ok: true;
        statusCode: number;
        data: z.infer<OkResponseSchema>;
        responseHeaders: Headers;
      }
    | RequestError
    | ParseResponseError
  > {
    return request(url, okResponseSchema, {
      ...options,
      method,
      body: content ? JSON.stringify(content) : null,
    });
  }

  return {
    author: {
      list: ({
        options,
        ...query
      }: QueryForListApi & { options?: RequestOptions }) =>
        requestGet(
          contentUrl(`author`),
          makeListResponseSchema(AuthorDefSchema),
          query,
          options,
        ),
      get: ({
        id,
        options,
        ...query
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          contentUrl(`author/${id}`),
          AuthorDefSchema.merge(MicroCmsListContentFieldsSchema),
          query,
          options,
        ),
      post: ({
        content,
        status,
        options,
      }: {
        content: AuthorInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "POST",
          contentUrl(`author${status ? `?status=${status}` : ""}`),
          OnlyIdSchema,
          content,
          options,
        ),
      put: ({
        id,
        content,
        status,
        options,
      }: {
        id: string;
        content: AuthorInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PUT",
          contentUrl(`author/${id}${status ? `?status=${status}` : ""}`),
          OnlyIdSchema,
          content,
          options,
        ),
      patch: ({
        id,
        content,
        options,
      }: {
        id: string;
        content: Partial<AuthorInput>;
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          contentUrl(`author/${id}`),
          OnlyIdSchema,
          content,
          options,
        ),
      delete: ({ id, options }: { id: string; options?: RequestOptions }) =>
        requestWrite(
          "DELETE",
          contentUrl(`author/${id}`),
          z.object({}),
          undefined,
          options,
        ),
      listMetadata: ({
        options,
        ...query
      }: Pick<QueryForListApi, "limit" | "offset"> & {
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/author`),
          AuthorOutputSchema,
          query,
          options,
        ),
      getMetadata: ({
        id,
        options,
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/author/${id}`),
          ListContentMetadataSchema,
          undefined,
          options,
        ),
      patchStatus: ({
        id,
        status,
        options,
      }: {
        id: string;
        status: "PUBLISH" | "DRAFT";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          managementUrl(`contents/author/${id}/status`),
          OnlyIdSchema,
          { status: [status] },
          options,
        ),
    },
    blog: {
      list: ({
        options,
        ...query
      }: QueryForListApi & { options?: RequestOptions }) =>
        requestGet(
          contentUrl(`blog`),
          makeListResponseSchema(BlogDefSchema),
          query,
          options,
        ),
      get: ({
        id,
        options,
        ...query
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          contentUrl(`blog/${id}`),
          BlogDefSchema.merge(MicroCmsListContentFieldsSchema),
          query,
          options,
        ),
      post: ({
        content,
        status,
        options,
      }: {
        content: BlogInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "POST",
          contentUrl(`blog${status ? `?status=${status}` : ""}`),
          OnlyIdSchema,
          content,
          options,
        ),
      put: ({
        id,
        content,
        status,
        options,
      }: {
        id: string;
        content: BlogInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PUT",
          contentUrl(`blog/${id}${status ? `?status=${status}` : ""}`),
          OnlyIdSchema,
          content,
          options,
        ),
      patch: ({
        id,
        content,
        options,
      }: {
        id: string;
        content: Partial<BlogInput>;
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          contentUrl(`blog/${id}`),
          OnlyIdSchema,
          content,
          options,
        ),
      delete: ({ id, options }: { id: string; options?: RequestOptions }) =>
        requestWrite(
          "DELETE",
          contentUrl(`blog/${id}`),
          z.object({}),
          undefined,
          options,
        ),
      listMetadata: ({
        options,
        ...query
      }: Pick<QueryForListApi, "limit" | "offset"> & {
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/blog`),
          BlogOutputSchema,
          query,
          options,
        ),
      getMetadata: ({
        id,
        options,
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/blog/${id}`),
          ListContentMetadataSchema,
          undefined,
          options,
        ),
      patchStatus: ({
        id,
        status,
        options,
      }: {
        id: string;
        status: "PUBLISH" | "DRAFT";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          managementUrl(`contents/blog/${id}/status`),
          OnlyIdSchema,
          { status: [status] },
          options,
        ),
    },
    category: {
      list: ({
        options,
        ...query
      }: QueryForListApi & { options?: RequestOptions }) =>
        requestGet(
          contentUrl(`category`),
          makeListResponseSchema(CategoryDefSchema),
          query,
          options,
        ),
      get: ({
        id,
        options,
        ...query
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          contentUrl(`category/${id}`),
          CategoryDefSchema.merge(MicroCmsListContentFieldsSchema),
          query,
          options,
        ),
      post: ({
        content,
        status,
        options,
      }: {
        content: CategoryInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "POST",
          contentUrl(`category${status ? `?status=${status}` : ""}`),
          OnlyIdSchema,
          content,
          options,
        ),
      put: ({
        id,
        content,
        status,
        options,
      }: {
        id: string;
        content: CategoryInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PUT",
          contentUrl(`category/${id}${status ? `?status=${status}` : ""}`),
          OnlyIdSchema,
          content,
          options,
        ),
      patch: ({
        id,
        content,
        options,
      }: {
        id: string;
        content: Partial<CategoryInput>;
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          contentUrl(`category/${id}`),
          OnlyIdSchema,
          content,
          options,
        ),
      delete: ({ id, options }: { id: string; options?: RequestOptions }) =>
        requestWrite(
          "DELETE",
          contentUrl(`category/${id}`),
          z.object({}),
          undefined,
          options,
        ),
      listMetadata: ({
        options,
        ...query
      }: Pick<QueryForListApi, "limit" | "offset"> & {
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/category`),
          CategoryOutputSchema,
          query,
          options,
        ),
      getMetadata: ({
        id,
        options,
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/category/${id}`),
          ListContentMetadataSchema,
          undefined,
          options,
        ),
      patchStatus: ({
        id,
        status,
        options,
      }: {
        id: string;
        status: "PUBLISH" | "DRAFT";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          managementUrl(`contents/category/${id}/status`),
          OnlyIdSchema,
          { status: [status] },
          options,
        ),
    },
  };
}
